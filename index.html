<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OPHTHALMO RESEARCH NETWORK - ENHANCED FAERS ANALYSER</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jstat/1.9.6/jstat.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/docxtemplater/3.40.2/docxtemplater.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pizzip/3.1.4/pizzip.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.98);
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.95;
        }

        .content {
            padding: 30px;
        }

        .upload-section {
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            border-radius: 15px;
            padding: 40px;
            margin-bottom: 30px;
            text-align: center;
            border: 2px dashed #667eea;
            transition: all 0.3s ease;
        }

        .upload-section.dragover {
            background: linear-gradient(135deg, #e0e7ff 0%, #d0d8f0 100%);
            transform: scale(1.02);
        }

        .upload-icon {
            font-size: 4em;
            margin-bottom: 20px;
            color: #667eea;
        }

        .file-input {
            display: none;
        }

        .upload-button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 40px;
            border: none;
            border-radius: 30px;
            font-size: 1.1em;
            cursor: pointer;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            display: inline-block;
            margin: 10px;
        }

        .upload-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.4);
        }

        .files-list {
            margin-top: 20px;
            text-align: left;
        }

        .file-item {
            background: white;
            padding: 15px;
            margin: 10px 0;
            border-radius: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .file-name {
            font-weight: 600;
            color: #333;
        }

        .file-info {
            color: #666;
            font-size: 0.9em;
        }

        .file-type {
            display: inline-block;
            padding: 3px 8px;
            background: #667eea;
            color: white;
            border-radius: 5px;
            font-size: 0.8em;
            margin-left: 10px;
        }

        .remove-file {
            background: #ff4757;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.3s ease;
        }

        .remove-file:hover {
            background: #ff3838;
        }

        .parameters-section {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
        }

        .parameters-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .parameter-group {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
        }

        .parameter-group label {
            display: block;
            font-weight: 600;
            margin-bottom: 8px;
            color: #333;
        }

        .parameter-group input,
        .parameter-group select {
            width: 100%;
            padding: 10px;
            border: 2px solid #e0e0e0;
            border-radius: 5px;
            font-size: 1em;
            transition: border-color 0.3s ease;
        }

        .parameter-group input:focus,
        .parameter-group select:focus {
            outline: none;
            border-color: #667eea;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            margin-top: 10px;
        }

        .checkbox-group input[type="checkbox"] {
            width: auto;
            margin-right: 10px;
        }

        .analysis-button {
            background: linear-gradient(135deg, #00d2ff 0%, #3a7bd5 100%);
            color: white;
            padding: 20px 60px;
            border: none;
            border-radius: 30px;
            font-size: 1.2em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: block;
            margin: 30px auto;
            box-shadow: 0 10px 30px rgba(58, 123, 213, 0.3);
        }

        .analysis-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 15px 40px rgba(58, 123, 213, 0.4);
        }

        .analysis-button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .results-section {
            display: none;
            margin-top: 40px;
        }

        .results-section.active {
            display: block;
            animation: fadeIn 0.5s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .tabs {
            display: flex;
            background: #f8f9fa;
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .tab {
            flex: 1;
            min-width: 120px;
            padding: 15px;
            background: transparent;
            border: none;
            cursor: pointer;
            font-size: 1.1em;
            font-weight: 600;
            color: #666;
            transition: all 0.3s ease;
        }

        .tab.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .tab:hover:not(.active) {
            background: rgba(102, 126, 234, 0.1);
        }

        .tab-content {
            display: none;
            padding: 30px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.1);
        }

        .tab-content.active {
            display: block;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from { opacity: 0; transform: translateX(20px); }
            to { opacity: 1; transform: translateX(0); }
        }

        .download-buttons, .subgroup-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 30px;
            padding: 30px;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            border-radius: 15px;
        }

        .download-btn, .subgroup-btn {
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
            color: white;
            padding: 15px 30px;
            border: none;
            border-radius: 25px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(17, 153, 142, 0.3);
        }

        .subgroup-btn {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a52 100%);
            box-shadow: 0 5px 15px rgba(255, 107, 107, 0.3);
        }

        .download-btn:hover, .subgroup-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(17, 153, 142, 0.4);
        }

        .subgroup-btn:hover {
            box-shadow: 0 8px 25px rgba(255, 107, 107, 0.4);
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            font-size: 0.95em;
            background: white;
        }

        th {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px;
            text-align: left;
            font-weight: 600;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        td {
            padding: 12px 15px;
            border-bottom: 1px solid #e0e0e0;
        }

        tr:hover {
            background: rgba(102, 126, 234, 0.05);
        }

        tr:nth-child(even) {
            background: #f8f9fa;
        }

        .medication-group {
            background: #e8f4fd;
            font-weight: bold;
            color: #667eea;
        }

        .statistic-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            margin: 15px 0;
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
        }

        .statistic-card h3 {
            margin-bottom: 15px;
            font-size: 1.3em;
        }

        .statistic-value {
            font-size: 2em;
            font-weight: bold;
            margin: 10px 0;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 40px;
        }

        .loading.active {
            display: block;
        }

        .spinner {
            border: 4px solid rgba(102, 126, 234, 0.1);
            border-radius: 50%;
            border-top: 4px solid #667eea;
            width: 60px;
            height: 60px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .alert {
            padding: 15px 20px;
            border-radius: 10px;
            margin: 20px 0;
            font-weight: 500;
        }

        .alert-info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        .alert-warning {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }

        .alert-success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .alert-error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .methodology-section, .results-text-section {
            background: white;
            padding: 30px;
            border-radius: 10px;
            margin: 20px 0;
            line-height: 1.8;
            font-size: 1.05em;
        }

        .methodology-section h2, .results-text-section h2 {
            color: #667eea;
            margin-bottom: 20px;
            border-bottom: 3px solid #667eea;
            padding-bottom: 10px;
        }

        .methodology-section h3, .results-text-section h3 {
            color: #764ba2;
            margin: 20px 0 10px 0;
        }

        .methodology-section p, .results-text-section p {
            margin-bottom: 15px;
            text-align: justify;
        }

        .stats-summary {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .stat-box {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }

        .stat-box .value {
            font-size: 2em;
            font-weight: bold;
            margin: 10px 0;
        }

        .stat-box .label {
            font-size: 0.9em;
            opacity: 0.9;
        }

        .instruction-note {
            background: #e8f4fd;
            border-left: 4px solid #667eea;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .instruction-note h4 {
            color: #667eea;
            margin-bottom: 10px;
        }

        .table-container {
            overflow-x: auto;
            margin: 20px 0;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            max-height: 600px;
            overflow-y: auto;
        }

        .unified-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9em;
        }

        .unified-table th {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 12px;
            text-align: left;
            font-weight: 600;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .unified-table td {
            padding: 10px 12px;
            border-bottom: 1px solid #e0e0e0;
        }

        .unified-table .medication-header {
            background: #e8f4fd;
            font-weight: bold;
            color: #667eea;
            border-top: 2px solid #667eea;
        }

        .age-stats {
            font-weight: bold;
            color: #764ba2;
        }

        .deduplication-info {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 10px;
            padding: 15px;
            margin: 20px 0;
        }

        .deduplication-info h4 {
            color: #856404;
            margin-bottom: 10px;
        }

        .debug-info {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            padding: 15px;
            margin: 20px 0;
            font-family: monospace;
            font-size: 0.9em;
            white-space: pre-wrap;
        }

        @media (max-width: 768px) {
            .container {
                margin: 10px;
                border-radius: 10px;
            }
            
            .content {
                padding: 15px;
            }
            
            .header h1 {
                font-size: 1.8em;
            }
            
            .tabs {
                flex-direction: column;
            }
            
            .tab {
                flex: none;
            }
            
            .stats-summary {
                grid-template-columns: 1fr;
            }
            
            table {
                font-size: 0.8em;
            }
            
            th, td {
                padding: 8px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>OPHTHALMO RESEARCH NETWORK - ENHANCED FAERS ANALYSER</h1>
            <p>Comprehensive Pharmacovigilance Analysis Tool with Advanced Tables and DOCX Statistics</p>
        </div>

        <div class="content">
            <!-- Upload Section -->
            <div class="upload-section" id="dropZone">
                <div class="upload-icon">📊</div>
                <h2>Upload FAERS Medication Data Files</h2>
                <div class="instruction-note">
                    <h4>📁 File Requirements:</h4>
                    <p><strong>Medication Files:</strong> Upload CSV/Excel files for each medication you want to analyze</p>
                    <p><strong>Analysis Method:</strong> Each medication file is analyzed independently for precise signal detection</p>
                </div>
                <p>Drag and drop your files here or click to browse</p>
                <input type="file" id="fileInput" class="file-input" multiple accept=".csv,.xlsx,.xls">
                <button class="upload-button" onclick="document.getElementById('fileInput').click()">
                    Choose Files
                </button>
                <div class="files-list" id="filesList"></div>
            </div>

            <!-- Parameters Section -->
            <div class="parameters-section">
                <h2>Analysis Parameters</h2>
                <div class="parameters-grid">
                    <div class="parameter-group">
                        <label for="minCases">Minimum Cases for Signal</label>
                        <input type="number" id="minCases" value="3" min="1">
                    </div>
                    <div class="parameter-group">
                        <label for="rorThreshold">ROR Threshold</label>
                        <input type="number" id="rorThreshold" value="2" min="1" step="0.1">
                    </div>
                    <div class="parameter-group">
                        <label for="prrThreshold">PRR Threshold</label>
                        <input type="number" id="prrThreshold" value="2" min="1" step="0.1">
                    </div>
                    <div class="parameter-group">
                        <label for="chiSquareThreshold">Chi-Square Threshold</label>
                        <input type="number" id="chiSquareThreshold" value="4" min="0" step="0.1">
                    </div>
                    <div class="parameter-group">
                        <label for="icThreshold">IC₀₂₅ Threshold</label>
                        <input type="number" id="icThreshold" value="0" min="-10" step="0.1">
                    </div>
                    <div class="parameter-group">
                        <label for="analysisType">Analysis Type</label>
                        <select id="analysisType">
                            <option value="all">All Methods (ROR, PRR, BCPNN)</option>
                            <option value="ror">ROR Only</option>
                            <option value="prr">PRR Only</option>
                            <option value="bcpnn">BCPNN Only</option>
                        </select>
                    </div>
                    <div class="parameter-group">
                        <label for="studyPeriod">Study Period (Auto-detected)</label>
                        <input type="text" id="studyPeriod" placeholder="Waiting for files..." value="" readonly style="background-color: #f8f9fa; cursor: not-allowed;">
                    </div>
                    <div class="parameter-group">
                        <label for="databaseVersion">Database Version</label>
                        <input type="text" id="databaseVersion" placeholder="e.g., Q1 2025" value="Q1 2025">
                    </div>
                    <div class="parameter-group">
                        <label>Data Processing Options</label>
                        <div class="checkbox-group">
                            <input type="checkbox" id="enableDeduplication" checked>
                            <label for="enableDeduplication">Enable Deduplication by Case ID</label>
                        </div>
                        <div class="checkbox-group">
                            <input type="checkbox" id="enableDebug">
                            <label for="enableDebug">Enable Debug Mode</label>
                        </div>
                    </div>
                </div>

                <button class="analysis-button" id="analyzeButton" onclick="runAnalysis()" disabled>
                    🚀 Run Comprehensive Analysis
                </button>
            </div>

            <!-- Loading Indicator -->
            <div class="loading" id="loadingIndicator">
                <div class="spinner"></div>
                <h3>Analyzing FAERS Data...</h3>
                <p>Processing files, deduplicating records, and calculating disproportionality statistics</p>
            </div>

            <!-- Results Section -->
            <div class="results-section" id="resultsSection">
                <div class="tabs">
                    <button class="tab active" onclick="switchTab('summary')">Summary</button>
                    <button class="tab" onclick="switchTab('methodology')">Methodology</button>
                    <button class="tab" onclick="switchTab('results')">Results</button>
                    <button class="tab" onclick="switchTab('tables')">Tables</button>
                    <button class="tab" onclick="switchTab('debug')" id="debugTab" style="display: none;">Debug</button>
                </div>

                <!-- Summary Tab -->
                <div class="tab-content active" id="summaryTab">
                    <div class="stats-summary" id="summaryContent">
                        <!-- Will be populated dynamically -->
                    </div>
                    <div id="deduplicationSummary">
                        <!-- Will show deduplication results -->
                    </div>
                </div>

                <!-- Methodology Tab -->
                <div class="tab-content" id="methodologyTab">
                    <div class="methodology-section" id="methodologyContent">
                        <!-- Will be populated dynamically -->
                    </div>
                </div>

                <!-- Results Tab -->
                <div class="tab-content" id="resultsTab">
                    <div class="results-text-section" id="resultsContent">
                        <!-- Will be populated dynamically -->
                    </div>
                </div>

                <!-- Tables Tab -->
                <div class="tab-content" id="tablesTab">
                    <div id="tablesContent">
                        <!-- Will be populated with all tables including demographics and countries -->
                    </div>
                </div>

                <!-- Debug Tab -->
                <div class="tab-content" id="debugTab">
                    <div id="debugContent">
                        <!-- Will be populated with debug information -->
                    </div>
                </div>

                <!-- Subgroup Analysis Buttons -->
                <div class="subgroup-buttons">
                    <h3 style="width: 100%; margin-bottom: 15px; color: #333;">Subgroup Analysis</h3>
                    <button class="subgroup-btn" onclick="generateSubgroupAnalysis('country')">
                        🌍 Analysis by Country
                    </button>
                    <button class="subgroup-btn" onclick="generateSubgroupAnalysis('age')">
                        👥 Analysis by Age Groups
                    </button>
                    <button class="subgroup-btn" onclick="generateSubgroupAnalysis('outcome')">
                        🏥 Analysis by Outcomes
                    </button>
                    <button class="subgroup-btn" onclick="generateSubgroupAnalysis('sex')">
                        ⚥ Analysis by Sex
                    </button>
                    <button class="subgroup-btn" onclick="generateSubgroupAnalysis('seriousness')">
                        ⚠️ Analysis by Seriousness
                    </button>
                </div>

                <!-- Download Buttons -->
                <div class="download-buttons">
                    <button class="download-btn" onclick="downloadRawData()">
                        📊 Download Raw Table (XLSX)
                    </button>
                    <button class="download-btn" onclick="downloadStudyTables()">
                        📋 Download Study Tables (HTML)
                    </button>
                    <button class="download-btn" onclick="downloadManuscript()">
                        📝 Download Manuscript (HTML)
                    </button>
                    <button class="download-btn" onclick="downloadStatisticsDocx()">
                        📋 Download Statistics & Equations (DOCX)
                    </button>
                    <button class="download-btn" onclick="downloadAllResults()">
                        💾 Download Complete Package
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let uploadedFiles = [];
        let analysisResults = null;
        let medicationDataSets = {};
        let deduplicationResults = null;
        let detailedCalculations = {};
        let debugInfo = [];

        // Initialize drag and drop
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');

        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('dragover');
        });

        dropZone.addEventListener('dragleave', () => {
            dropZone.classList.remove('dragover');
        });

        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('dragover');
            handleFiles(e.dataTransfer.files);
        });

        fileInput.addEventListener('change', (e) => {
            handleFiles(e.target.files);
        });

        function logDebug(message, data = null) {
            const timestamp = new Date().toISOString();
            debugInfo.push({
                timestamp,
                message,
                data: data ? JSON.stringify(data, null, 2) : null
            });
            console.log(`[DEBUG ${timestamp}] ${message}`, data);
        }

        function parseDate(dateStr) {
            if (!dateStr || dateStr === '' || dateStr === 'Not Specified') return null;
            
            const date = new Date(dateStr);
            if (!isNaN(date.getTime())) {
                return date;
            }
            
            // Try parsing different formats
            const formats = [
                /(\d{4})-(\d{2})-(\d{2})/,
                /(\d{2})\/(\d{2})\/(\d{4})/,
                /(\d{2})-(\d{2})-(\d{4})/
            ];
            
            for (let format of formats) {
                const match = dateStr.toString().match(format);
                if (match) {
                    const parsedDate = new Date(match[0]);
                    if (!isNaN(parsedDate.getTime())) {
                        return parsedDate;
                    }
                }
            }
            
            return null;
        }

        async function updateStudyPeriod() {
            const studyPeriodEl = document.getElementById('studyPeriod');
            if (uploadedFiles.length === 0) {
                studyPeriodEl.value = '';
                studyPeriodEl.placeholder = 'Waiting for files...';
                return;
            }

            studyPeriodEl.value = 'Detecting dates...';
            let minDate = null;
            let maxDate = null;

            for (const file of uploadedFiles) {
                try {
                    logDebug(`Scanning dates in file: ${file.name}`);
                    const data = await parseFile(file);
                    
                    data.forEach(record => {
                        const dateFields = [
                            'Event Date',
                            'Latest FDA Received Date', 
                            'Initial FDA Received Date',
                            'Latest Manufacturer Received Date',
                            'FDA_RECEIVED_DATE',
                            'EVENT_DATE'
                        ];

                        dateFields.forEach(field => {
                            const dateStr = record[field];
                            if (dateStr && dateStr !== '' && dateStr !== 'Not Specified') {
                                const date = parseDate(dateStr);
                                if (date && !isNaN(date)) {
                                    if (!minDate || date < minDate) minDate = date;
                                    if (!maxDate || date > maxDate) maxDate = date;
                                }
                            }
                        });
                    });
                } catch (error) {
                    logDebug(`Error reading file ${file.name} for date detection:`, error);
                }
            }

            if (minDate && maxDate) {
                const startYear = minDate.getFullYear();
                const endYear = maxDate.getFullYear();
                const periodStr = startYear === endYear ? `${startYear}` : `${startYear}-${endYear}`;
                studyPeriodEl.value = periodStr;
                logDebug(`Study period detected: ${periodStr}`, {
                    minDate: minDate.toISOString(),
                    maxDate: maxDate.toISOString(),
                    filesScanned: uploadedFiles.length
                });
            } else {
                studyPeriodEl.value = 'No valid dates found';
                logDebug('No valid dates found in uploaded files');
            }
        }

        function extractMedicationName(filename) {
            // Extract medication name from filename
            let name = filename.replace(/\.(csv|xlsx|xls)$/i, '');
            
            // Remove common prefixes/suffixes
            name = name.replace(/^(data_|faers_|reports_)/i, '');
            name = name.replace(/(_data|_faers|_reports)$/i, '');
            
            logDebug(`Extracted medication name: ${name} from filename: ${filename}`);
            return name.toUpperCase();
        }

        function handleFiles(files) {
            for (let file of files) {
                if (file.name.endsWith('.csv') || file.name.endsWith('.xlsx') || file.name.endsWith('.xls')) {
                    uploadedFiles.push(file);
                    logDebug(`Added medication file: ${file.name}`);
                    
                    displayFiles();
                    updateStudyPeriod();
                    document.getElementById('analyzeButton').disabled = false;
                }
            }
        }

        function displayFiles() {
            const filesList = document.getElementById('filesList');
            filesList.innerHTML = '<h3>Uploaded Files:</h3>';
            
            uploadedFiles.forEach((file, index) => {
                const medicationName = extractMedicationName(file.name);
                const fileItem = document.createElement('div');
                fileItem.className = 'file-item';
                fileItem.innerHTML = `
                    <div>
                        <div class="file-name">${file.name}<span class="file-type">Medication: ${medicationName}</span></div>
                        <div class="file-info">Size: ${(file.size / 1024).toFixed(2)} KB</div>
                    </div>
                    <button class="remove-file" onclick="removeFile(${index})">Remove</button>
                `;
                filesList.appendChild(fileItem);
            });
        }

        function removeFile(index) {
            const file = uploadedFiles[index];
            const medicationName = extractMedicationName(file.name);
            delete medicationDataSets[medicationName];
            uploadedFiles.splice(index, 1);
            logDebug(`Removed medication file: ${file.name}`);
            
            displayFiles();
            updateStudyPeriod();
            if (uploadedFiles.length === 0) {
                document.getElementById('analyzeButton').disabled = true;
            }
        }

        function switchTab(tabName) {
            // Update tab buttons
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });
            event.target.classList.add('active');

            // Update tab content
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            document.getElementById(tabName + 'Tab').classList.add('active');
        }

        async function parseFile(file) {
            logDebug(`Starting to parse file: ${file.name}`);
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                
                if (file.name.endsWith('.csv')) {
                    reader.onload = (e) => {
                        const csv = e.target.result;
                        const results = Papa.parse(csv, {
                            header: true,
                            dynamicTyping: true,
                            skipEmptyLines: true,
                            delimitersToGuess: [',', '\t', '|', ';']
                        });
                        logDebug(`Parsed CSV file ${file.name}: ${results.data.length} records`);
                        resolve(results.data);
                    };
                    reader.readAsText(file);
                } else {
                    reader.onload = (e) => {
                        const data = new Uint8Array(e.target.result);
                        const workbook = XLSX.read(data, { 
                            type: 'array',
                            cellDates: true,
                            cellStyles: true,
                            cellNF: true
                        });
                        const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
                        const jsonData = XLSX.utils.sheet_to_json(firstSheet, {
                            header: 1,
                            defval: '',
                            blankrows: false
                        });
                        
                        if (jsonData.length > 0) {
                            const headers = jsonData[0];
                            const objectData = [];
                            for (let i = 1; i < jsonData.length; i++) {
                                const row = {};
                                headers.forEach((header, j) => {
                                    row[header] = jsonData[i][j];
                                });
                                objectData.push(row);
                            }
                            logDebug(`Parsed Excel file ${file.name}: ${objectData.length} records`);
                            resolve(objectData);
                        } else {
                            logDebug(`Empty Excel file: ${file.name}`);
                            resolve([]);
                        }
                    };
                    reader.readAsArrayBuffer(file);
                }
                
                reader.onerror = () => {
                    logDebug(`Error reading file: ${file.name}`);
                    reject(new Error('Failed to read file'));
                };
            });
        }

        function deduplicateData(data, name) {
            if (!document.getElementById('enableDeduplication').checked) {
                logDebug(`Deduplication disabled for ${name}`);
                return {
                    deduplicated: data,
                    originalCount: data.length,
                    deduplicatedCount: data.length,
                    duplicatesRemoved: 0,
                    consolidatedRecords: 0
                };
            }

            logDebug(`Starting deduplication for ${name} with ${data.length} records`);
            const caseGroups = {};
            let duplicatesRemoved = 0;
            let consolidatedRecords = 0;

            data.forEach((record, index) => {
                const caseId = record['Case ID'] || record['Case Number'] || record['ID'] || record['CASEID'] || record['case_id'] || `auto_${index}`;
                if (!caseGroups[caseId]) {
                    caseGroups[caseId] = [];
                }
                caseGroups[caseId].push(record);
            });

            const deduplicatedData = [];

            Object.entries(caseGroups).forEach(([caseId, records]) => {
                if (records.length === 1) {
                    deduplicatedData.push(records[0]);
                } else {
                    const consolidatedRecord = consolidateRecords(records);
                    deduplicatedData.push(consolidatedRecord);
                    duplicatesRemoved += records.length - 1;
                    consolidatedRecords++;
                }
            });

            logDebug(`Deduplication completed for ${name}`, {
                originalCount: data.length,
                deduplicatedCount: deduplicatedData.length,
                duplicatesRemoved,
                consolidatedRecords
            });

            return {
                deduplicated: deduplicatedData,
                originalCount: data.length,
                deduplicatedCount: deduplicatedData.length,
                duplicatesRemoved: duplicatesRemoved,
                consolidatedRecords: consolidatedRecords
            };
        }

        function consolidateRecords(records) {
            records.sort((a, b) => {
                const dateA = new Date(a['Latest FDA Received Date'] || a['FDA Received Date'] || '1900-01-01');
                const dateB = new Date(b['Latest FDA Received Date'] || b['FDA Received Date'] || '1900-01-01');
                return dateB - dateA;
            });

            const baseRecord = { ...records[0] };

            // Consolidate reactions
            const allReactions = new Set();
            records.forEach(record => {
                const reactions = (record['Reactions'] || record['Adverse Event'] || '').toString().split(/[;,]/).map(r => r.trim()).filter(r => r);
                reactions.forEach(reaction => allReactions.add(reaction));
            });
            baseRecord['Reactions'] = Array.from(allReactions).join(';');

            // Consolidate outcomes
            const allOutcomes = new Set();
            records.forEach(record => {
                const outcomes = (record['Outcomes'] || record['Outcome'] || '').toString().split(/[;,]/).map(o => o.trim()).filter(o => o);
                outcomes.forEach(outcome => allOutcomes.add(outcome));
            });
            baseRecord['Outcomes'] = Array.from(allOutcomes).join(';');

            // Use most complete demographic data
            ['Patient Age', 'Age', 'Sex', 'Gender', 'Patient Weight', 'Weight'].forEach(field => {
                const nonEmptyValue = records.find(r => r[field] && r[field] !== 'Not Specified' && r[field] !== '-' && r[field] !== '');
                if (nonEmptyValue) {
                    baseRecord[field] = nonEmptyValue[field];
                }
            });

            return baseRecord;
        }

        async function runAnalysis() {
            debugInfo = [];
            logDebug('Starting enhanced analysis');
            
            document.getElementById('loadingIndicator').classList.add('active');
            document.getElementById('resultsSection').style.display = 'none';

            if (document.getElementById('enableDebug').checked) {
                document.getElementById('debugTab').style.display = 'block';
            }

            try {
                medicationDataSets = {};

                for (let file of uploadedFiles) {
                    const medicationName = extractMedicationName(file.name);
                    const rawData = await parseFile(file);
                    
                    const deduplication = deduplicateData(rawData, medicationName);
                    
                    medicationDataSets[medicationName] = {
                        raw: rawData,
                        deduplicated: deduplication.deduplicated,
                        deduplicationStats: deduplication,
                        fileName: file.name
                    };
                    
                    logDebug(`Processed medication: ${medicationName}`, {
                        fileName: file.name,
                        originalRecords: rawData.length,
                        afterDeduplication: deduplication.deduplicated.length
                    });
                }

                deduplicationResults = {
                    medications: {}
                };

                Object.entries(medicationDataSets).forEach(([medName, medData]) => {
                    deduplicationResults.medications[medName] = medData.deduplicationStats;
                });

                // Use combined data as reference for signal calculation
                let combinedData = [];
                Object.values(medicationDataSets).forEach(medData => {
                    combinedData = combinedData.concat(medData.deduplicated);
                });

                analysisResults = await performAnalysis(combinedData);

                generateSummary(analysisResults);
                generateMethodology(analysisResults.parameters);
                generateResults(analysisResults);
                generateTables(analysisResults);
                
                if (document.getElementById('enableDebug').checked) {
                    generateDebugInfo();
                }

                document.getElementById('loadingIndicator').classList.remove('active');
                document.getElementById('resultsSection').classList.add('active');
                document.getElementById('resultsSection').style.display = 'block';

                logDebug('Analysis completed successfully');

            } catch (error) {
                logDebug('Analysis error', error);
                console.error('Analysis error:', error);
                alert('Error during analysis: ' + error.message);
                document.getElementById('loadingIndicator').classList.remove('active');
            }
        }

        async function performAnalysis(combinedData) {
            logDebug('Starting statistical analysis');
            
            const params = {
                minCases: parseInt(document.getElementById('minCases').value),
                rorThreshold: parseFloat(document.getElementById('rorThreshold').value),
                prrThreshold: parseFloat(document.getElementById('prrThreshold').value),
                chiSquareThreshold: parseFloat(document.getElementById('chiSquareThreshold').value),
                icThreshold: parseFloat(document.getElementById('icThreshold').value),
                analysisType: document.getElementById('analysisType').value,
                studyPeriod: document.getElementById('studyPeriod').value,
                databaseVersion: document.getElementById('databaseVersion').value,
                deduplicationEnabled: document.getElementById('enableDeduplication').checked
            };

            logDebug('Analysis parameters', params);

            const medicationSpecificDemographics = {};
            let totalStudyCases = 0;

            Object.entries(medicationDataSets).forEach(([medName, medData]) => {
                medicationSpecificDemographics[medName] = calculateDemographics(medData.deduplicated, medName);
                totalStudyCases += medData.deduplicated.length;
                
                logDebug(`Demographics calculated for ${medName}:`, {
                    totalCases: medData.deduplicated.length,
                    ageRecords: medicationSpecificDemographics[medName].age.length,
                    fileName: medData.fileName
                });
            });

            const globalDemographics = {
                totalCases: totalStudyCases,
                age: [],
                sex: {},
                country: {},
                serious: { serious: 0, nonSerious: 0 },
                outcomes: {},
                reporterType: {}
            };

            Object.values(medicationSpecificDemographics).forEach(demo => {
                globalDemographics.age.push(...demo.age);
                
                Object.entries(demo.sex).forEach(([sex, count]) => {
                    globalDemographics.sex[sex] = (globalDemographics.sex[sex] || 0) + count;
                });
                
                Object.entries(demo.country).forEach(([country, count]) => {
                    globalDemographics.country[country] = (globalDemographics.country[country] || 0) + count;
                });
                
                globalDemographics.serious.serious += demo.serious.serious;
                globalDemographics.serious.nonSerious += demo.serious.nonSerious;
                
                Object.entries(demo.outcomes).forEach(([outcome, count]) => {
                    globalDemographics.outcomes[outcome] = (globalDemographics.outcomes[outcome] || 0) + count;
                });
                
                Object.entries(demo.reporterType).forEach(([reporter, count]) => {
                    globalDemographics.reporterType[reporter] = (globalDemographics.reporterType[reporter] || 0) + count;
                });
            });

            const allSignals = [];
            const medicationSignals = {};

            Object.entries(medicationDataSets).forEach(([medName, medData]) => {
                logDebug(`Processing signals for medication: ${medName} with ${medData.deduplicated.length} cases`);
                
                let medSignals = calculateSignalsForMedication(medName, medData.deduplicated, combinedData, params);
                
                // Auto-broaden criteria if no significant signals found
                if (medSignals.length === 0) {
                    logDebug(`No significant signals found for ${medName}, applying ROR>1 criteria`);
                    medSignals = calculateSignalsWithBroadenedCriteria(medName, medData.deduplicated, combinedData, params);
                }
                
                medicationSignals[medName] = medSignals;
                allSignals.push(...medSignals);
                
                logDebug(`Found ${medSignals.length} signals for ${medName}`);
            });

            allSignals.sort((a, b) => {
                const rorA = a.ror || 0;
                const rorB = b.ror || 0;
                return rorB - rorA;
            });

            const totalBackgroundCases = combinedData.length;

            logDebug('Analysis summary', {
                totalMedications: Object.keys(medicationDataSets).length,
                totalStudyCases,
                totalBackgroundCases,
                totalSignals: allSignals.length
            });

            return {
                signals: allSignals,
                medicationSignals: medicationSignals,
                demographics: globalDemographics,
                medicationDemographics: medicationSpecificDemographics,
                totalStudyCases: totalStudyCases,
                totalBackgroundCases: totalBackgroundCases,
                uniqueDrugs: Object.keys(medicationDataSets).length,
                parameters: params,
                studyFiles: uploadedFiles.map(f => f.name),
                medicationDataSets: medicationDataSets,
                deduplicationResults: deduplicationResults
            };
        }

        function calculateSignalsWithBroadenedCriteria(medName, medData, combinedData, params) {
            logDebug(`Applying broadened criteria (ROR>1) for ${medName}`);
            
            const broadenedParams = {
                ...params,
                rorThreshold: 1.0,
                prrThreshold: 1.0,
                chiSquareThreshold: 0,
                icThreshold: -10,
                minCases: 1
            };
            
            return calculateSignalsForMedication(medName, medData, combinedData, broadenedParams);
        }

        function calculateDemographics(data, name) {
            logDebug(`Calculating demographics for ${name} with ${data.length} records`);
            
            const demographics = {
                totalCases: data.length,
                age: [],
                sex: {},
                country: {},
                serious: { serious: 0, nonSerious: 0 },
                outcomes: {},
                reporterType: {}
            };

            data.forEach(record => {
                // Age processing
                const ageFields = ['Patient Age', 'Age', 'AGE'];
                for (let field of ageFields) {
                    const ageStr = record[field];
                    if (ageStr && ageStr !== 'Not Specified' && ageStr !== '-' && ageStr !== '') {
                        const ageMatch = ageStr.toString().match(/(\d+)/);
                        if (ageMatch) {
                            const age = parseInt(ageMatch[1]);
                            if (!isNaN(age) && age > 0 && age < 120) {
                                demographics.age.push(age);
                                break;
                            }
                        }
                    }
                }
                
                // Sex processing
                const sexFields = ['Sex', 'Gender', 'SEX'];
                for (let field of sexFields) {
                    const sex = record[field] || 'Not Specified';
                    if (sex !== 'Not Specified') {
                        demographics.sex[sex] = (demographics.sex[sex] || 0) + 1;
                        break;
                    }
                }
                if (!Object.keys(demographics.sex).some(key => key !== 'Not Specified')) {
                    demographics.sex['Not Specified'] = (demographics.sex['Not Specified'] || 0) + 1;
                }
                
                // Country processing
                const countryFields = ['Country where Event occurred', 'Country', 'COUNTRY'];
                let countryFound = false;
                for (let field of countryFields) {
                    const country = record[field];
                    if (country && country !== 'Unknown' && country !== '') {
                        demographics.country[country] = (demographics.country[country] || 0) + 1;
                        countryFound = true;
                        break;
                    }
                }
                if (!countryFound) {
                    demographics.country['Unknown'] = (demographics.country['Unknown'] || 0) + 1;
                }
                
                // Seriousness processing
                const seriousFields = ['Serious', 'SERIOUS', 'Seriousness'];
                let seriousFound = false;
                for (let field of seriousFields) {
                    const serious = record[field];
                    if (serious) {
                        const seriousStr = serious.toString().toLowerCase();
                        if (seriousStr.includes('serious') || seriousStr.includes('yes') || seriousStr === '1') {
                            demographics.serious.serious++;
                        } else {
                            demographics.serious.nonSerious++;
                        }
                        seriousFound = true;
                        break;
                    }
                }
                if (!seriousFound) {
                    demographics.serious.nonSerious++;
                }
                
                // Outcomes processing
                const outcomeFields = ['Outcomes', 'Outcome', 'OUTCOME'];
                for (let field of outcomeFields) {
                    const outcome = record[field] || 'Not Specified';
                    if (outcome !== 'Not Specified') {
                        outcome.toString().split(/[;,]/).forEach(o => {
                            const trimmed = o.trim();
                            if (trimmed) {
                                demographics.outcomes[trimmed] = (demographics.outcomes[trimmed] || 0) + 1;
                            }
                        });
                        break;
                    }
                }
                
                // Reporter type processing
                const reporterFields = ['Reporter Type', 'REPORTER_TYPE', 'Reporter'];
                for (let field of reporterFields) {
                    const reporter = record[field] || 'Not Specified';
                    if (reporter !== 'Not Specified') {
                        demographics.reporterType[reporter] = (demographics.reporterType[reporter] || 0) + 1;
                        break;
                    }
                }
            });

            logDebug(`Demographics calculated for ${name}`, {
                totalCases: demographics.totalCases,
                ageRecords: demographics.age.length,
                sexCategories: Object.keys(demographics.sex).length,
                countries: Object.keys(demographics.country).length
            });

            return demographics;
        }

        function calculateSignalsForMedication(medName, medData, backgroundData, params) {
    logDebug(`Calculating signals for ${medName} with ${medData.length} study records vs ${backgroundData.length} background records`);
    
    // Contar pares droga-reação no dataset do medicamento específico
    const studyDrugReactionPairs = {};
    const studyDrugCounts = {};
    const studyReactionCounts = {};
    
    // Contar pares droga-reação em toda a base de dados background
    const backgroundReactionCounts = {};
    const backgroundTotalReports = backgroundData.length;
    
    // Processar dados do medicamento específico
    medData.forEach(record => {
        processRecordForSignals(record, studyDrugReactionPairs, studyDrugCounts, studyReactionCounts, medName);
    });

    // Processar dados background para contar todas as reações
    backgroundData.forEach(record => {
        const reactionFields = [
            'Reactions',
            'Adverse Event', 
            'Reaction',
            'ADVERSE_EVENT',
            'REACTION'
        ];
        
        let reactionString = '';
        for (let field of reactionFields) {
            if (record[field]) {
                reactionString = record[field].toString();
                break;
            }
        }
        
        const reactions = reactionString.split(/[;,]/).map(r => r.trim()).filter(r => r);
        reactions.forEach(reaction => {
            if (reaction) {
                backgroundReactionCounts[reaction] = (backgroundReactionCounts[reaction] || 0) + 1;
            }
        });
    });

    const signals = [];
    detailedCalculations[medName] = {};

    Object.entries(studyDrugReactionPairs).forEach(([key, count]) => {
        const [drug, reaction] = key.split('|');
        const a = count; // Casos com medicamento E reação
        
        if (a >= params.minCases) {
            // Construir tabela de contingência correta para análise de desproporcionalidade
            const totalMedicationReports = studyDrugCounts[drug]; // Total de reports do medicamento
            const b = totalMedicationReports - a; // Casos com medicamento SEM a reação
            
            const totalReactionInBackground = backgroundReactionCounts[reaction] || 0; // Total da reação em toda base
            const c = Math.max(0, totalReactionInBackground - a); // Reação sem o medicamento específico
            
            const d = Math.max(0, backgroundTotalReports - a - b - c); // Nem medicamento nem reação

            // Verificar se há dados suficientes para cálculo
            if (b > 0 && c > 0 && d > 0) {
                const signal = {
                    medication: medName,
                    drug,
                    reaction,
                    cases: a,
                    studyDrugTotal: totalMedicationReports,
                    reactionTotal: totalReactionInBackground,
                    backgroundCases: totalReactionInBackground,
                    backgroundTotalReports
                };

                const calcKey = `${drug}_${reaction}`;
                detailedCalculations[medName][calcKey] = {
                    contingencyTable: { a, b, c, d },
                    totalStudyReports: totalMedicationReports,
                    totalBackgroundReports: backgroundTotalReports,
                    drug,
                    reaction,
                    calculations: {}
                };

                calculateStatistics(signal, params, detailedCalculations[medName][calcKey], backgroundTotalReports);

                if (signal.rorSignificant || signal.prrSignificant || signal.icSignificant) {
                    signals.push(signal);
                }
            } else {
                logDebug(`Insufficient data for ${drug}-${reaction}: a=${a}, b=${b}, c=${c}, d=${d}`);
            }
        }
    });

    signals.sort((a, b) => {
        const scoreA = (a.ror || 0) + (a.prr || 0) + (a.ic || 0);
        const scoreB = (b.ror || 0) + (b.prr || 0) + (b.ic || 0);
        return scoreB - scoreA;
    });

    logDebug(`Calculated ${signals.length} significant signals for ${medName}`);
    return signals;
}

        function processRecordForSignals(record, drugReactionPairs, drugCounts, reactionCounts, expectedMedication) {
            const drugFields = [
                'Suspect Product Names',
                'Suspect Product Active Ingredients',
                'Drug Name',
                'Product Name',
                'DRUG_NAME',
                'SUSPECT_PRODUCT'
            ];
            
            let drugName = '';
            for (let field of drugFields) {
                if (record[field]) {
                    drugName = record[field].toString().trim();
                    break;
                }
            }
            
            if (expectedMedication) {
                drugName = expectedMedication;
            }
            
            const reactionFields = [
                'Reactions',
                'Adverse Event',
                'Reaction',
                'ADVERSE_EVENT',
                'REACTION'
            ];
            
            let reactionString = '';
            for (let field of reactionFields) {
                if (record[field]) {
                    reactionString = record[field].toString();
                    break;
                }
            }
            
            const reactions = reactionString.split(/[;,]/).map(r => r.trim()).filter(r => r);

            if (drugName && reactions.length > 0) {
                reactions.forEach(reaction => {
                    if (reaction) {
                        const key = `${drugName}|${reaction}`;
                        drugReactionPairs[key] = (drugReactionPairs[key] || 0) + 1;
                        drugCounts[drugName] = (drugCounts[drugName] || 0) + 1;
                        reactionCounts[reaction] = (reactionCounts[reaction] || 0) + 1;
                    }
                });
            }
        }

        function calculateStatistics(signal, params, calcDetails, totalBackgroundReports) {
    const { a, b, c, d } = calcDetails.contingencyTable;

    // Validar se há dados suficientes
    if (a <= 0) {
        signal.ror = null;
        signal.prr = null;
        signal.ic = null;
        signal.rorSignificant = false;
        signal.prrSignificant = false;
        signal.icSignificant = false;
        return;
    }

    // Calculate ROR
    if (params.analysisType === 'all' || params.analysisType === 'ror') {
        if (b > 0 && c > 0 && d > 0) {
            signal.ror = (a * d) / (b * c);
            
            // Calcular intervalo de confiança 95%
            const lnROR = Math.log(signal.ror);
            const se = Math.sqrt(1/a + 1/b + 1/c + 1/d);
            signal.rorLowerCI = Math.exp(lnROR - 1.96 * se);
            signal.rorUpperCI = Math.exp(lnROR + 1.96 * se);
            
            // Critério de significância: ROR ≥ threshold E Lower CI > 1
            signal.rorSignificant = signal.ror >= params.rorThreshold && signal.rorLowerCI > 1;

            calcDetails.calculations.ror = {
                formula: `ROR = (a × d) / (b × c) = (${a} × ${d}) / (${b} × ${c})`,
                calculation: `ROR = ${a * d} / ${b * c} = ${signal.ror.toFixed(4)}`,
                lnROR: lnROR,
                standardError: se,
                lowerCI: signal.rorLowerCI,
                upperCI: signal.rorUpperCI,
                significant: signal.rorSignificant,
                criteria: `ROR ≥ ${params.rorThreshold} AND Lower CI > 1`
            };
        } else {
            signal.ror = null;
            signal.rorSignificant = false;
            logDebug(`ROR não calculável para ${signal.drug}-${signal.reaction}: b=${b}, c=${c}, d=${d}`);
        }
    }

    // Calculate PRR
    if (params.analysisType === 'all' || params.analysisType === 'prr') {
        if (c > 0 && d > 0 && (a + b) > 0 && (c + d) > 0) {
            signal.prr = (a / (a + b)) / (c / (c + d));
            
            // Calcular Chi-square com correção de Yates
            const n = a + b + c + d;
            const expected = ((a + b) * (a + c)) / n;
            
            if (expected > 0) {
                // Chi-square com correção de Yates
                signal.chiSquare = Math.pow(Math.abs(a - expected) - 0.5, 2) / expected;
                
                // Critério de Evans: PRR ≥ threshold AND χ² ≥ threshold AND casos ≥ mínimo
                signal.prrSignificant = signal.prr >= params.prrThreshold && 
                                       signal.chiSquare >= params.chiSquareThreshold &&
                                       a >= params.minCases;

                calcDetails.calculations.prr = {
                    formula: `PRR = [a/(a+b)] / [c/(c+d)] = [${a}/(${a}+${b})] / [${c}/(${c}+${d})]`,
                    calculation: `PRR = ${(a/(a+b)).toFixed(4)} / ${(c/(c+d)).toFixed(4)} = ${signal.prr.toFixed(4)}`,
                    chiSquareFormula: `χ² = (|a - E| - 0.5)² / E onde E = (a+b)(a+c)/n`,
                    expectedValue: expected,
                    chiSquareValue: signal.chiSquare,
                    significant: signal.prrSignificant,
                    evansCriteria: `PRR ≥ ${params.prrThreshold} AND χ² ≥ ${params.chiSquareThreshold} AND casos ≥ ${params.minCases}`
                };
            } else {
                signal.prr = null;
                signal.prrSignificant = false;
            }
        } else {
            signal.prr = null;
            signal.prrSignificant = false;
            logDebug(`PRR não calculável para ${signal.drug}-${signal.reaction}: c=${c}, d=${d}`);
        }
    }

    // Calculate BCPNN/IC
    if (params.analysisType === 'all' || params.analysisType === 'bcpnn') {
        const totalReports = a + b + c + d;
        const E11 = ((a + b) * (a + c)) / totalReports;
        
        if (E11 > 0 && a > 0) {
            signal.ic = Math.log2(a / E11);
            signal.bcpnn = signal.ic;
            
            // Calcular IC₀₂₅ (limite inferior do intervalo de credibilidade 95%)
            const variance = (1/a - 1/totalReports) + 
                           (1/(a+b) - 1/totalReports) + 
                           (1/(a+c) - 1/totalReports);
            signal.ic025 = signal.ic - 1.96 * Math.sqrt(variance / (Math.LN2 * Math.LN2));
            
            signal.icSignificant = signal.ic025 > params.icThreshold;

            calcDetails.calculations.bcpnn = {
                formula: `IC = log₂(Observado/Esperado) = log₂(a/E₁₁)`,
                expectedFormula: `E₁₁ = (a+b)(a+c)/N = (${a+b})(${a+c})/${totalReports}`,
                expectedValue: E11,
                calculation: `IC = log₂(${a}/${E11.toFixed(4)}) = ${signal.ic.toFixed(4)}`,
                variance: variance,
                ic025: signal.ic025,
                significant: signal.icSignificant,
                criteria: `IC₀₂₅ > ${params.icThreshold}`
            };
        } else {
            signal.ic = null;
            signal.bcpnn = null;
            signal.icSignificant = false;
            logDebug(`IC não calculável para ${signal.drug}-${signal.reaction}: E11=${E11}, a=${a}`);
        }
    }
}

        function generateSummary(results) {
            const significantSignals = results.signals.filter(s => 
                s.rorSignificant || s.prrSignificant || s.icSignificant
            );

            const summaryHTML = `
                <div class="stat-box">
                    <div class="value">${results.totalStudyCases.toLocaleString()}</div>
                    <div class="label">Total Study Cases (After Deduplication)</div>
                </div>
                <div class="stat-box">
                    <div class="value">${Object.keys(results.medicationDataSets).length}</div>
                    <div class="label">Medications Analyzed</div>
                </div>
                <div class="stat-box">
                    <div class="value">${significantSignals.length}</div>
                    <div class="label">Total Significant Signals</div>
                </div>
                <div class="stat-box">
                    <div class="value">${results.demographics.age.length > 0 ? 
                        Math.round(results.demographics.age.reduce((sum, age) => sum + age, 0) / results.demographics.age.length) : 'N/A'}</div>
                    <div class="label">Mean Age (years)</div>
                </div>
                <div class="stat-box">
                    <div class="value">${Object.keys(results.demographics.country).length}</div>
                    <div class="label">Countries Represented</div>
                </div>
                <div class="stat-box">
                    <div class="value">${Object.entries(results.medicationSignals).map(([med, signals]) => `${med}: ${signals.filter(s => s.rorSignificant || s.prrSignificant || s.icSignificant).length}`).join(', ')}</div>
                    <div class="label">Signals per Medication</div>
                </div>
            `;

            document.getElementById('summaryContent').innerHTML = summaryHTML;

            if (deduplicationResults && results.parameters.deduplicationEnabled) {
                let deduplicationHTML = '<div class="deduplication-info"><h4>📋 Deduplication Summary</h4>';
                
                Object.entries(deduplicationResults.medications).forEach(([medName, stats]) => {
                    const reductionRate = stats.originalCount > 0 ? ((stats.duplicatesRemoved / stats.originalCount) * 100).toFixed(1) : '0.0';
                    deduplicationHTML += `<p><strong>${medName}:</strong> ${stats.originalCount} → ${stats.deduplicatedCount} records (${stats.duplicatesRemoved} duplicates removed, ${reductionRate}% reduction)</p>`;
                });
                
                deduplicationHTML += '</div>';
                document.getElementById('deduplicationSummary').innerHTML = deduplicationHTML;
            }
        }

        function generateMethodology(params) {
            let deduplicationSection = '';
            if (params.deduplicationEnabled && deduplicationResults) {
                deduplicationSection = `
                    <h3>Data Deduplication</h3>
                    <p>Systematic deduplication was performed separately for each medication dataset. Records were grouped by Case ID, and duplicate entries were intelligently consolidated to preserve all relevant information while eliminating redundancy.</p>
                `;
            }

            const medicationCount = Object.keys(medicationDataSets).length;

            const content = `
                <h2>Materials and Methods</h2>
                
                <h3>Data Source</h3>
                <p>This pharmacovigilance study utilized data from the FDA Adverse Event Reporting System (FAERS) database version ${params.databaseVersion}, covering the period ${params.studyPeriod}. The analysis included ${medicationCount} medication-specific data files, with each medication analyzed separately to ensure accurate signal detection and demographic profiling.</p>
                
                <h3>Data Processing and Quality Control</h3>
                <p>Data extraction and processing followed validated pharmacovigilance methodologies compliant with ICH E2B(R3) standards. Each medication dataset was processed independently to maintain data integrity and prevent cross-contamination of signals between different products.</p>
                
                ${deduplicationSection}
                
                <h3>Statistical Analysis</h3>
                <p>Disproportionality analysis was conducted using ${params.analysisType === 'all' ? 'three complementary statistical methods (ROR, PRR, BCPNN)' : params.analysisType.toUpperCase() + ' methodology'} to detect potential safety signals. Auto-broadening criteria were applied when no significant signals were detected, reverting to ROR>1 threshold to ensure comprehensive signal identification.</p>
                
                <h3>Enhanced Analysis Features</h3>
                <p>The analysis includes comprehensive demographic profiling with country-specific breakdowns, age group stratification, outcome classification, and subgroup analyses to provide detailed pharmacovigilance insights for regulatory and clinical decision-making.</p>
            `;
            
            document.getElementById('methodologyContent').innerHTML = content;
        }

        function generateResults(results) {
            const significantSignals = results.signals.filter(s => 
                s.rorSignificant || s.prrSignificant || s.icSignificant
            );

            let medicationSummary = '';
            Object.entries(results.medicationSignals).forEach(([medName, signals]) => {
                const medCases = results.medicationDataSets[medName].deduplicated.length;
                const medSignificantSignals = signals.filter(s => s.rorSignificant || s.prrSignificant || s.icSignificant).length;
                medicationSummary += `${medName}: ${medCases} cases, ${medSignificantSignals} signals; `;
            });

            const content = `
                <h2>Results</h2>
                
                <h3>Dataset Characteristics</h3>
                <p>The analysis encompassed ${results.totalStudyCases.toLocaleString()} adverse event reports from ${Object.keys(results.medicationDataSets).length} medications${results.parameters.deduplicationEnabled ? ' after medication-specific deduplication processing' : ''}. The dataset represented ${Object.keys(results.demographics.country).length} countries, providing a global perspective on medication safety profiles.</p>
                
                <h3>Signal Detection Results</h3>
                <p>The comprehensive analysis identified ${significantSignals.length} significant safety signals meeting the predefined criteria across all medications. Auto-broadening criteria were applied where necessary to ensure comprehensive signal detection, with fallback to ROR>1 threshold when initial criteria yielded no results.</p>
                
                <h3>Medication-Specific Results</h3>
                ${Object.entries(results.medicationSignals).map(([medName, signals]) => {
                    const medData = results.medicationDataSets[medName];
                    const demographics = results.medicationDemographics[medName];
                    const significantMedSignals = signals.filter(s => s.rorSignificant || s.prrSignificant || s.icSignificant);
                    
                    return `<p><strong>${medName}:</strong> Analysis of ${medData.deduplicated.length} cases identified ${significantMedSignals.length} significant safety signals. ${demographics.age.length > 0 ? `Mean age: ${(demographics.age.reduce((sum, age) => sum + age, 0) / demographics.age.length).toFixed(1)} years.` : ''} Geographic distribution included ${Object.keys(demographics.country).length} countries.</p>`;
                }).join('')}
                
                <h3>Geographic and Demographic Insights</h3>
                <p>The analysis revealed diverse geographic representation with reports from ${Object.keys(results.demographics.country).length} countries. Age distribution analysis and outcome stratification provide comprehensive safety profiling for regulatory assessment and clinical decision-making.</p>
            `;
            
            document.getElementById('resultsContent').innerHTML = content;
        }

        function generateTables(results) {
            let tablesHTML = '<h2>Comprehensive Analysis Tables</h2>';

            tablesHTML += generateDemographicTable(results);
            tablesHTML += generateCountriesTable(results);
            tablesHTML += generateSignalsTable(results);
            tablesHTML += generateOutcomesTable(results);

            if (results.parameters.deduplicationEnabled) {
                tablesHTML += generateDeduplicationTable(results);
            }

            document.getElementById('tablesContent').innerHTML = tablesHTML;
        }

        function generateDemographicTable(results) {
            const medications = Object.keys(results.medicationDataSets);
            
            let html = `
                <div class="table-container">
                    <h3>Table 1. Patient Characteristics by Medication</h3>
                    <table class="unified-table">
                        <thead>
                            <tr>
                                <th>Characteristic</th>
                                ${medications.map(med => `<th>${med}</th>`).join('')}
                                <th>Total</th>
                            </tr>
                        </thead>
                        <tbody>
            `;

            // Total cases row
            html += `
                <tr>
                    <td><strong>Total Cases</strong></td>
                    ${medications.map(med => {
                        const count = results.medicationDataSets[med].deduplicated.length;
                        return `<td>${count.toLocaleString()}</td>`;
                    }).join('')}
                    <td><strong>${results.totalStudyCases.toLocaleString()}</strong></td>
                </tr>
            `;

            // Age statistics
            html += `
                <tr>
                    <td><strong>Age (Mean ± SD)</strong></td>
                    ${medications.map(med => {
                        const demographics = results.medicationDemographics[med];
                        if (demographics.age.length > 0) {
                            const mean = demographics.age.reduce((sum, age) => sum + age, 0) / demographics.age.length;
                            const variance = demographics.age.reduce((sum, age) => sum + Math.pow(age - mean, 2), 0) / demographics.age.length;
                            const stdDev = Math.sqrt(variance);
                            return `<td class="age-stats">${mean.toFixed(1)} ± ${stdDev.toFixed(1)} (n=${demographics.age.length})</td>`;
                        } else {
                            return `<td class="age-stats">N/A</td>`;
                        }
                    }).join('')}
                    <td class="age-stats"><strong>${results.demographics.age.length > 0 ? 
                        (results.demographics.age.reduce((sum, age) => sum + age, 0) / results.demographics.age.length).toFixed(1) + ' ± ' +
                        Math.sqrt(results.demographics.age.reduce((sum, age) => sum + Math.pow(age - (results.demographics.age.reduce((s, a) => s + a, 0) / results.demographics.age.length), 2), 0) / results.demographics.age.length).toFixed(1) +
                        ' (n=' + results.demographics.age.length + ')'
                        : 'N/A'}</strong></td>
                </tr>
            `;

            // Sex distribution
            const allSexCategories = new Set();
            medications.forEach(med => {
                Object.keys(results.medicationDemographics[med].sex).forEach(sex => allSexCategories.add(sex));
            });

            Array.from(allSexCategories).forEach(sex => {
                html += `
                    <tr>
                        <td><strong>${sex}</strong></td>
                        ${medications.map(med => {
                            const count = results.medicationDemographics[med].sex[sex] || 0;
                            const total = results.medicationDataSets[med].deduplicated.length;
                            const percentage = total > 0 ? (count / total * 100).toFixed(1) : '0.0';
                            return `<td>${count} (${percentage}%)</td>`;
                        }).join('')}
                        <td><strong>${(results.demographics.sex[sex] || 0)} (${((results.demographics.sex[sex] || 0) / results.totalStudyCases * 100).toFixed(1)}%)</strong></td>
                    </tr>
                `;
            });

            html += `
                        </tbody>
                    </table>
                </div>
            `;

            return html;
        }

        function generateCountriesTable(results) {
            const medications = Object.keys(results.medicationDataSets);
            
            // Get all countries sorted by total count
            const allCountries = Object.keys(results.demographics.country).sort((a, b) => 
                (results.demographics.country[b] || 0) - (results.demographics.country[a] || 0)
            );

            let html = `
                <div class="table-container">
                    <h3>Table 2. Geographic Distribution by Country</h3>
                    <table class="unified-table">
                        <thead>
                            <tr>
                                <th>Country</th>
                                ${medications.map(med => `<th>${med}</th>`).join('')}
                                <th>Total</th>
                                <th>Percentage</th>
                            </tr>
                        </thead>
                        <tbody>
            `;

            allCountries.forEach(country => {
                const totalCount = results.demographics.country[country] || 0;
                const percentage = (totalCount / results.totalStudyCases * 100).toFixed(1);
                
                html += `
                    <tr>
                        <td><strong>${country}</strong></td>
                        ${medications.map(med => {
                            const count = results.medicationDemographics[med].country[country] || 0;
                            return `<td>${count}</td>`;
                        }).join('')}
                        <td><strong>${totalCount}</strong></td>
                        <td><strong>${percentage}%</strong></td>
                    </tr>
                `;
            });

            html += `
                        </tbody>
                    </table>
                </div>
            `;

            return html;
        }

        function generateSignalsTable(results) {
            let html = `
                <div class="table-container">
                    <h3>Table 3. Safety Signals by Medication</h3>
                    <table class="unified-table">
                        <thead>
                            <tr>
                                <th>Medication</th>
                                <th>Adverse Event</th>
                                <th>Cases</th>
                                <th>ROR (95% CI)</th>
                                <th>PRR (χ²)</th>
                                <th>IC (IC₀₂₅)</th>
                                <th>BCPNN</th>
                                <th>Signal Methods</th>
                            </tr>
                        </thead>
                        <tbody>
            `;

            const sortedMedications = Object.keys(results.medicationSignals).sort((a, b) => {
                const signalsA = results.medicationSignals[a].filter(s => s.rorSignificant || s.prrSignificant || s.icSignificant).length;
                const signalsB = results.medicationSignals[b].filter(s => s.rorSignificant || s.prrSignificant || s.icSignificant).length;
                return signalsB - signalsA;
            });

            sortedMedications.forEach(medication => {
                const signals = results.medicationSignals[medication];
                const significantSignals = signals.filter(s => s.rorSignificant || s.prrSignificant || s.icSignificant);
                
                significantSignals.sort((a, b) => {
                    const scoreA = (a.ror || 0) + (a.prr || 0) + (a.ic || 0);
                    const scoreB = (b.ror || 0) + (b.prr || 0) + (b.ic || 0);
                    return scoreB - scoreA;
                });
                
                if (significantSignals.length > 0) {
                    html += `
                        <tr class="medication-header">
                            <td colspan="8"><strong>${medication} (${significantSignals.length} signals from ${results.medicationDataSets[medication].deduplicated.length} cases)</strong></td>
                        </tr>
                    `;

                    significantSignals.forEach(signal => {
                        const signalMethods = [
                            signal.rorSignificant ? 'ROR' : '',
                            signal.prrSignificant ? 'PRR' : '',
                            signal.icSignificant ? 'BCPNN' : ''
                        ].filter(method => method).join(', ');

                        html += `
                            <tr>
                                <td>${signal.medication}</td>
                                <td>${signal.reaction}</td>
                                <td>${signal.cases}</td>
                                <td>${signal.ror ? `${signal.ror.toFixed(2)} (${signal.rorLowerCI ? signal.rorLowerCI.toFixed(2) : 'N/A'}-${signal.rorUpperCI ? signal.rorUpperCI.toFixed(2) : 'N/A'})` : 'N/C'}</td>
                                <td>${signal.prr ? `${signal.prr.toFixed(2)} (${signal.chiSquare ? signal.chiSquare.toFixed(1) : 'N/A'})` : 'N/C'}</td>
                                <td>${signal.ic ? `${signal.ic.toFixed(2)} (${signal.ic025 ? signal.ic025.toFixed(2) : 'N/A'})` : 'N/C'}</td>
                                <td>${signal.bcpnn ? signal.bcpnn.toFixed(2) : 'N/C'}</td>
                                <td><strong>${signalMethods}</strong></td>
                            </tr>
                        `;
                    });
                } else {
                    html += `
                        <tr class="medication-header">
                            <td colspan="8"><strong>${medication} (No significant signals detected from ${results.medicationDataSets[medication].deduplicated.length} cases)</strong></td>
                        </tr>
                    `;
                }
            });

            html += `
                        </tbody>
                    </table>
                </div>
            `;

            return html;
        }

        function generateOutcomesTable(results) {
            const allOutcomes = new Set();
            Object.values(results.medicationDemographics).forEach(demographics => {
                Object.keys(demographics.outcomes).forEach(outcome => allOutcomes.add(outcome));
            });

            if (allOutcomes.size === 0) {
                return '<p>No outcome data available in the uploaded files.</p>';
            }

            const medications = Object.keys(results.medicationDataSets);
            const sortedOutcomes = Array.from(allOutcomes).sort((a, b) => {
                const countA = results.demographics.outcomes[a] || 0;
                const countB = results.demographics.outcomes[b] || 0;
                return countB - countA;
            });

            let html = `
                <div class="table-container">
                    <h3>Table 4. Outcomes Distribution by Medication</h3>
                    <table class="unified-table">
                        <thead>
                            <tr>
                                <th>Outcome</th>
                                ${medications.map(med => `<th>${med}</th>`).join('')}
                                <th>Total</th>
                            </tr>
                        </thead>
                        <tbody>
            `;

            sortedOutcomes.forEach(outcome => {
                html += `
                    <tr>
                        <td><strong>${outcome}</strong></td>
                        ${medications.map(med => {
                            const count = results.medicationDemographics[med].outcomes[outcome] || 0;
                            const total = results.medicationDataSets[med].deduplicated.length;
                            const percentage = total > 0 ? (count / total * 100).toFixed(1) : '0.0';
                            return `<td>${count} (${percentage}%)</td>`;
                        }).join('')}
                        <td><strong>${(results.demographics.outcomes[outcome] || 0)} (${((results.demographics.outcomes[outcome] || 0) / results.totalStudyCases * 100).toFixed(1)}%)</strong></td>
                    </tr>
                `;
            });

            html += `
                        </tbody>
                    </table>
                </div>
            `;

            return html;
        }

        function generateDeduplicationTable(results) {
            if (!results.deduplicationResults) return '';

            let html = `
                <div class="table-container">
                    <h3>Table 5. Deduplication Summary by Medication</h3>
                    <table class="unified-table">
                        <thead>
                            <tr>
                                <th>Medication</th>
                                <th>Original Records</th>
                                <th>Deduplicated Records</th>
                                <th>Duplicates Removed</th>
                                <th>Reduction Rate (%)</th>
                                <th>Consolidated Records</th>
                            </tr>
                        </thead>
                        <tbody>
            `;

            Object.entries(results.deduplicationResults.medications).forEach(([medName, stats]) => {
                const reductionRate = stats.originalCount > 0 ? ((stats.duplicatesRemoved / stats.originalCount) * 100).toFixed(1) : '0.0';
                html += `
                    <tr>
                        <td><strong>${medName}</strong></td>
                        <td>${stats.originalCount}</td>
                        <td>${stats.deduplicatedCount}</td>
                        <td>${stats.duplicatesRemoved}</td>
                        <td>${reductionRate}%</td>
                        <td>${stats.consolidatedRecords}</td>
                    </tr>
                `;
            });

            html += `
                        </tbody>
                    </table>
                </div>
            `;

            return html;
        }

        function generateDebugInfo() {
            let debugHTML = '<h2>Debug Information</h2>';
            
            debugHTML += '<div class="debug-info">';
            debugInfo.forEach(entry => {
                debugHTML += `[${entry.timestamp}] ${entry.message}\n`;
                if (entry.data) {
                    debugHTML += `${entry.data}\n\n`;
                }
            });
            debugHTML += '</div>';

            debugHTML += '<h3>Medication Data Summary</h3>';
            Object.entries(medicationDataSets).forEach(([medName, medData]) => {
                debugHTML += `<div class="debug-info">
${medName}:
- File: ${medData.fileName}
- Original records: ${medData.raw.length}
- After deduplication: ${medData.deduplicated.length}
- Sample fields: ${Object.keys(medData.raw[0] || {}).slice(0, 10).join(', ')}
</div>`;
            });

            document.getElementById('debugContent').innerHTML = debugHTML;
        }

        function generateSubgroupAnalysis(subgroupType) {
            if (!analysisResults) {
                alert('Please run the analysis first before generating subgroup analyses.');
                return;
            }

            let subgroupHTML = '';
            let filename = '';

            switch (subgroupType) {
                case 'country':
                    subgroupHTML = generateCountrySubgroupAnalysis();
                    filename = 'Country_Subgroup_Analysis';
                    break;
                case 'age':
                    subgroupHTML = generateAgeSubgroupAnalysis();
                    filename = 'Age_Subgroup_Analysis';
                    break;
                case 'outcome':
                    subgroupHTML = generateOutcomeSubgroupAnalysis();
                    filename = 'Outcome_Subgroup_Analysis';
                    break;
                case 'sex':
                    subgroupHTML = generateSexSubgroupAnalysis();
                    filename = 'Sex_Subgroup_Analysis';
                    break;
                case 'seriousness':
                    subgroupHTML = generateSeriousnessSubgroupAnalysis();
                    filename = 'Seriousness_Subgroup_Analysis';
                    break;
            }

            const fullHTML = `
                <!DOCTYPE html>
                <html>
                <head>
                    <title>FAERS Subgroup Analysis - ${subgroupType.toUpperCase()}</title>
                    <style>
                        body { font-family: Arial, sans-serif; margin: 20px; line-height: 1.6; }
                        h1, h2, h3 { color: #667eea; }
                        table { width: 100%; border-collapse: collapse; margin: 20px 0; }
                        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
                        th { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; }
                        .subgroup-header { background-color: #e8f4fd; font-weight: bold; }
                    </style>
                </head>
                <body>
                    <h1>FAERS Pharmacovigilance Analysis - ${subgroupType.toUpperCase()} Subgroup Analysis</h1>
                    <p>Generated on: ${new Date().toLocaleDateString()}</p>
                    ${subgroupHTML}
                </body>
                </html>
            `;

            const blob = new Blob([fullHTML], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${filename}_${new Date().toISOString().split('T')[0]}.html`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function generateCountrySubgroupAnalysis() {
            const countries = Object.keys(analysisResults.demographics.country);
            let html = '<h2>Analysis by Country</h2>';

            countries.forEach(country => {
                const countryData = filterDataByCountry(country);
                html += `
                    <h3>${country} (${countryData.totalCases} cases)</h3>
                    <table>
                        <tr><th>Medication</th><th>Cases</th><th>Signals</th><th>Mean Age</th></tr>
                        ${Object.entries(analysisResults.medicationDataSets).map(([medName, medData]) => {
                            const medCountryData = medData.deduplicated.filter(record => 
                                (record['Country where Event occurred'] || record['Country'] || 'Unknown') === country
                            );
                            const avgAge = medCountryData.length > 0 ? 
                                medCountryData.filter(r => r['Patient Age']).map(r => {
                                    const ageMatch = r['Patient Age'].toString().match(/(\d+)/);
                                    return ageMatch ? parseInt(ageMatch[1]) : null;
                                }).filter(age => age !== null).reduce((sum, age, _, arr) => sum + age/arr.length, 0) : 0;
                            return `<tr><td>${medName}</td><td>${medCountryData.length}</td><td>-</td><td>${avgAge > 0 ? avgAge.toFixed(1) : 'N/A'}</td></tr>`;
                        }).join('')}
                    </table>
                `;
            });

            return html;
        }

        function generateAgeSubgroupAnalysis() {
            const ageGroups = {
                'Pediatric (0-17)': { min: 0, max: 17 },
                'Young Adult (18-34)': { min: 18, max: 34 },
                'Adult (35-49)': { min: 35, max: 49 },
                'Middle-aged (50-64)': { min: 50, max: 64 },
                'Elderly (65+)': { min: 65, max: 150 }
            };

            let html = '<h2>Analysis by Age Groups</h2>';

            Object.entries(ageGroups).forEach(([groupName, range]) => {
                html += `<h3>${groupName}</h3><table>`;
                html += '<tr><th>Medication</th><th>Cases</th><th>Mean Age</th><th>Top Reactions</th></tr>';
                
                Object.entries(analysisResults.medicationDataSets).forEach(([medName, medData]) => {
                    const ageGroupData = medData.deduplicated.filter(record => {
                        const ageStr = record['Patient Age'] || record['Age'];
                        if (ageStr) {
                            const ageMatch = ageStr.toString().match(/(\d+)/);
                            if (ageMatch) {
                                const age = parseInt(ageMatch[1]);
                                return age >= range.min && age <= range.max;
                            }
                        }
                        return false;
                    });

                    const avgAge = ageGroupData.length > 0 ? 
                        ageGroupData.map(r => {
                            const ageMatch = (r['Patient Age'] || '').toString().match(/(\d+)/);
                            return ageMatch ? parseInt(ageMatch[1]) : null;
                        }).filter(age => age !== null).reduce((sum, age, _, arr) => sum + age/arr.length, 0) : 0;

                    const reactions = {};
                    ageGroupData.forEach(record => {
                        const reactionStr = record['Reactions'] || record['Adverse Event'] || '';
                        reactionStr.split(/[;,]/).forEach(reaction => {
                            const trimmed = reaction.trim();
                            if (trimmed) reactions[trimmed] = (reactions[trimmed] || 0) + 1;
                        });
                    });

                    const topReactions = Object.entries(reactions)
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, 3)
                        .map(([reaction, count]) => `${reaction} (${count})`)
                        .join(', ');

                    html += `<tr><td>${medName}</td><td>${ageGroupData.length}</td><td>${avgAge > 0 ? avgAge.toFixed(1) : 'N/A'}</td><td>${topReactions || 'None'}</td></tr>`;
                });
                
                html += '</table>';
            });

            return html;
        }

        function generateOutcomeSubgroupAnalysis() {
            const allOutcomes = Object.keys(analysisResults.demographics.outcomes);
            let html = '<h2>Analysis by Outcomes</h2>';

            allOutcomes.forEach(outcome => {
                html += `<h3>${outcome}</h3><table>`;
                html += '<tr><th>Medication</th><th>Cases with Outcome</th><th>Percentage</th><th>Associated Reactions</th></tr>';
                
                Object.entries(analysisResults.medicationDataSets).forEach(([medName, medData]) => {
                    const outcomeData = medData.deduplicated.filter(record => {
                        const outcomes = record['Outcomes'] || record['Outcome'] || '';
                        return outcomes.toString().includes(outcome);
                    });

                    const percentage = medData.deduplicated.length > 0 ? 
                        (outcomeData.length / medData.deduplicated.length * 100).toFixed(1) : '0.0';

                    const reactions = {};
                    outcomeData.forEach(record => {
                        const reactionStr = record['Reactions'] || record['Adverse Event'] || '';
                        reactionStr.split(/[;,]/).forEach(reaction => {
                            const trimmed = reaction.trim();
                            if (trimmed) reactions[trimmed] = (reactions[trimmed] || 0) + 1;
                        });
                    });

                    const topReactions = Object.entries(reactions)
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, 3)
                        .map(([reaction, count]) => `${reaction} (${count})`)
                        .join(', ');

                    html += `<tr><td>${medName}</td><td>${outcomeData.length}</td><td>${percentage}%</td><td>${topReactions || 'None'}</td></tr>`;
                });
                
                html += '</table>';
            });

            return html;
        }

        function generateSexSubgroupAnalysis() {
            const sexes = Object.keys(analysisResults.demographics.sex);
            let html = '<h2>Analysis by Sex</h2>';

            sexes.forEach(sex => {
                html += `<h3>${sex}</h3><table>`;
                html += '<tr><th>Medication</th><th>Cases</th><th>Mean Age</th><th>Serious Cases</th><th>Top Reactions</th></tr>';
                
                Object.entries(analysisResults.medicationDataSets).forEach(([medName, medData]) => {
                    const sexData = medData.deduplicated.filter(record => 
                        (record['Sex'] || record['Gender'] || 'Not Specified') === sex
                    );

                    const avgAge = sexData.length > 0 ? 
                        sexData.filter(r => r['Patient Age']).map(r => {
                            const ageMatch = r['Patient Age'].toString().match(/(\d+)/);
                            return ageMatch ? parseInt(ageMatch[1]) : null;
                        }).filter(age => age !== null).reduce((sum, age, _, arr) => sum + age/arr.length, 0) : 0;

                    const seriousCases = sexData.filter(record => {
                        const serious = record['Serious'] || '';
                        return serious.toString().toLowerCase().includes('serious') || serious === 'Yes';
                    }).length;

                    const reactions = {};
                    sexData.forEach(record => {
                        const reactionStr = record['Reactions'] || record['Adverse Event'] || '';
                        reactionStr.split(/[;,]/).forEach(reaction => {
                            const trimmed = reaction.trim();
                            if (trimmed) reactions[trimmed] = (reactions[trimmed] || 0) + 1;
                        });
                    });

                    const topReactions = Object.entries(reactions)
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, 3)
                        .map(([reaction, count]) => `${reaction} (${count})`)
                        .join(', ');

                    html += `<tr><td>${medName}</td><td>${sexData.length}</td><td>${avgAge > 0 ? avgAge.toFixed(1) : 'N/A'}</td><td>${seriousCases}</td><td>${topReactions || 'None'}</td></tr>`;
                });
                
                html += '</table>';
            });

            return html;
        }

        function generateSeriousnessSubgroupAnalysis() {
            const seriousnessGroups = ['Serious', 'Non-Serious'];
            let html = '<h2>Analysis by Seriousness</h2>';

            seriousnessGroups.forEach(seriousness => {
                html += `<h3>${seriousness} Cases</h3><table>`;
                html += '<tr><th>Medication</th><th>Cases</th><th>Mean Age</th><th>Top Outcomes</th><th>Top Reactions</th></tr>';
                
                Object.entries(analysisResults.medicationDataSets).forEach(([medName, medData]) => {
                    const seriousnessData = medData.deduplicated.filter(record => {
                        const serious = record['Serious'] || '';
                        const isSerious = serious.toString().toLowerCase().includes('serious') || serious === 'Yes';
                        return seriousness === 'Serious' ? isSerious : !isSerious;
                    });

                    const avgAge = seriousnessData.length > 0 ? 
                        seriousnessData.filter(r => r['Patient Age']).map(r => {
                            const ageMatch = r['Patient Age'].toString().match(/(\d+)/);
                            return ageMatch ? parseInt(ageMatch[1]) : null;
                        }).filter(age => age !== null).reduce((sum, age, _, arr) => sum + age/arr.length, 0) : 0;

                    const outcomes = {};
                    const reactions = {};
                    
                    seriousnessData.forEach(record => {
                        const outcomeStr = record['Outcomes'] || record['Outcome'] || '';
                        outcomeStr.split(/[;,]/).forEach(outcome => {
                            const trimmed = outcome.trim();
                            if (trimmed) outcomes[trimmed] = (outcomes[trimmed] || 0) + 1;
                        });

                        const reactionStr = record['Reactions'] || record['Adverse Event'] || '';
                        reactionStr.split(/[;,]/).forEach(reaction => {
                            const trimmed = reaction.trim();
                            if (trimmed) reactions[trimmed] = (reactions[trimmed] || 0) + 1;
                        });
                    });

                    const topOutcomes = Object.entries(outcomes)
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, 3)
                        .map(([outcome, count]) => `${outcome} (${count})`)
                        .join(', ');

                    const topReactions = Object.entries(reactions)
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, 3)
                        .map(([reaction, count]) => `${reaction} (${count})`)
                        .join(', ');

                    html += `<tr><td>${medName}</td><td>${seriousnessData.length}</td><td>${avgAge > 0 ? avgAge.toFixed(1) : 'N/A'}</td><td>${topOutcomes || 'None'}</td><td>${topReactions || 'None'}</td></tr>`;
                });
                
                html += '</table>';
            });

            return html;
        }

        function downloadRawData() {
            if (!analysisResults) return;
            
            const wb = XLSX.utils.book_new();
            
            const signalsData = [
                ['Medication', 'Drug', 'Adverse Event', 'Cases', 'ROR', 'ROR Lower CI', 'ROR Upper CI', 'PRR', 'Chi Square', 'IC', 'IC025', 'BCPNN', 'ROR Significant', 'PRR Significant', 'IC Significant']
            ];
            
            const sortedSignals = [...analysisResults.signals].sort((a, b) => {
                if (a.medication !== b.medication) {
                    return a.medication.localeCompare(b.medication);
                }
                return (b.ror || 0) - (a.ror || 0);
            });
            
            sortedSignals.forEach(signal => {
                signalsData.push([
                    signal.medication,
                    signal.drug,
                    signal.reaction,
                    signal.cases,
                    signal.ror || '',
                    signal.rorLowerCI || '',
                    signal.rorUpperCI || '',
                    signal.prr || '',
                    signal.chiSquare || '',
                    signal.ic || '',
                    signal.ic025 || '',
                    signal.bcpnn || '',
                    signal.rorSignificant ? 'Yes' : 'No',
                    signal.prrSignificant ? 'Yes' : 'No',
                    signal.icSignificant ? 'Yes' : 'No'
                ]);
            });
            
            const ws = XLSX.utils.aoa_to_sheet(signalsData);
            XLSX.utils.book_append_sheet(wb, ws, "All_Signals_by_Medication");

            const demographicsData = [
                ['Medication', 'Total Cases', 'Mean Age', 'SD Age', 'Age Records', 'Male', 'Female', 'Not Specified Sex', 'Countries']
            ];

            Object.entries(analysisResults.medicationDemographics).forEach(([medName, demo]) => {
                const meanAge = demo.age.length > 0 ? (demo.age.reduce((sum, age) => sum + age, 0) / demo.age.length).toFixed(1) : 'N/A';
                const sdAge = demo.age.length > 0 ? Math.sqrt(demo.age.reduce((sum, age) => sum + Math.pow(age - parseFloat(meanAge), 2), 0) / demo.age.length).toFixed(1) : 'N/A';
                
                demographicsData.push([
                    medName,
                    demo.totalCases,
                    meanAge,
                    sdAge,
                    demo.age.length,
                    demo.sex['Male'] || 0,
                    demo.sex['Female'] || 0,
                    demo.sex['Not Specified'] || 0,
                    Object.keys(demo.country).length
                ]);
            });

            const demographicsWs = XLSX.utils.aoa_to_sheet(demographicsData);
            XLSX.utils.book_append_sheet(wb, demographicsWs, "Demographics_by_Medication");

            // Add countries breakdown
            const countriesData = [['Country', ...Object.keys(analysisResults.medicationDataSets), 'Total']];
            Object.keys(analysisResults.demographics.country).forEach(country => {
                const row = [country];
                Object.keys(analysisResults.medicationDataSets).forEach(medName => {
                    row.push(analysisResults.medicationDemographics[medName].country[country] || 0);
                });
                row.push(analysisResults.demographics.country[country] || 0);
                countriesData.push(row);
            });

            const countriesWs = XLSX.utils.aoa_to_sheet(countriesData);
            XLSX.utils.book_append_sheet(wb, countriesWs, "Countries_Distribution");
            
            XLSX.writeFile(wb, `FAERS_Enhanced_Analysis_${new Date().toISOString().split('T')[0]}.xlsx`);
        }

        function downloadStudyTables() {
            if (!analysisResults) return;
            
            let tablesHTML = `
                <!DOCTYPE html>
                <html>
                <head>
                    <title>FAERS Analysis - Study Tables</title>
                    <style>
                        body { font-family: Arial, sans-serif; margin: 20px; }
                        table { width: 100%; border-collapse: collapse; margin: 20px 0; }
                        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
                        th { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; }
                        .medication-header { background-color: #e8f4fd; font-weight: bold; }
                    </style>
                </head>
                <body>
                    <h1>FAERS Pharmacovigilance Analysis - Study Tables</h1>
                    <p>Generated on: ${new Date().toLocaleDateString()}</p>
                    ${document.getElementById('tablesContent').innerHTML}
                </body>
                </html>
            `;
            
            const blob = new Blob([tablesHTML], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `FAERS_Study_Tables_${new Date().toISOString().split('T')[0]}.html`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function downloadManuscript() {
            if (!analysisResults) return;
            
            let manuscriptHTML = `
                <!DOCTYPE html>
                <html>
                <head>
                    <title>FAERS Pharmacovigilance Analysis - Manuscript</title>
                    <style>
                        body { font-family: Arial, sans-serif; margin: 40px; line-height: 1.6; }
                        h1, h2, h3 { color: #333; }
                        table { width: 100%; border-collapse: collapse; margin: 20px 0; }
                        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
                        th { background-color: #f2f2f2; }
                    </style>
                </head>
                <body>
                    <h1>Pharmacovigilance Analysis of FAERS Data: Enhanced Medication-Specific Safety Signal Detection with Geographic and Demographic Profiling</h1>
                    
                    <h2>Abstract</h2>
                    <p><strong>Background:</strong> This study presents a comprehensive pharmacovigilance analysis of FDA Adverse Event Reporting System (FAERS) data using enhanced medication-specific signal detection methodologies with geographic and demographic stratification.</p>
                    <p><strong>Methods:</strong> Data from ${Object.keys(analysisResults.medicationDataSets).length} medications were analyzed separately using disproportionality analysis (ROR, PRR, BCPNN) with auto-broadening criteria. Geographic distribution across ${Object.keys(analysisResults.demographics.country).length} countries and comprehensive demographic profiling were performed.</p>
                    <p><strong>Results:</strong> A total of ${analysisResults.totalStudyCases.toLocaleString()} cases were analyzed, identifying ${analysisResults.signals.filter(s => s.rorSignificant || s.prrSignificant || s.icSignificant).length} significant safety signals across all medications with detailed country-specific and demographic breakdowns.</p>
                    
                    ${document.getElementById('methodologyContent').innerHTML}
                    ${document.getElementById('resultsContent').innerHTML}
                    ${document.getElementById('tablesContent').innerHTML}
                    
                    <h2>Conclusion</h2>
                    <p>This enhanced medication-specific analysis approach with geographic and demographic stratification provides superior signal detection accuracy and comprehensive safety profiling for regulatory decision-making and clinical practice guidelines.</p>
                </body>
                </html>
            `;
            
            const blob = new Blob([manuscriptHTML], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `FAERS_Enhanced_Manuscript_${new Date().toISOString().split('T')[0]}.html`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function downloadStatisticsDocx() {
            if (!analysisResults || !detailedCalculations) return;

            // Create comprehensive DOCX content with all equations and calculations
            let docxContent = `
FAERS PHARMACOVIGILANCE ANALYSIS - DETAILED STATISTICAL CALCULATIONS AND EQUATIONS

Generated on: ${new Date().toLocaleDateString()}
Analysis Parameters: ${JSON.stringify(analysisResults.parameters, null, 2)}

==================================================
STATISTICAL METHODOLOGY AND EQUATIONS
==================================================

1. REPORTING ODDS RATIO (ROR)
Formula: ROR = (a × d) / (b × c)
Where:
- a = Drug-reaction pairs in study
- b = Drug without reaction in study  
- c = Reaction without drug in study
- d = Neither drug nor reaction in study

95% Confidence Interval:
- ln(ROR) ± 1.96 × SE
- SE = √(1/a + 1/b + 1/c + 1/d)
- Lower CI = exp(ln(ROR) - 1.96 × SE)
- Upper CI = exp(ln(ROR) + 1.96 × SE)

Significance Criteria: ROR ≥ ${analysisResults.parameters.rorThreshold} AND Lower CI > 1

2. PROPORTIONAL REPORTING RATIO (PRR) - EVANS CRITERIA
Formula: PRR = [a/(a+b)] / [c/(c+d)]

Chi-Square Test with Yates Correction:
- Expected value: E = (a+b)(a+c)/N
- χ² = (|a - E| - 0.5)² / E

Evans Criteria for Significance:
- PRR ≥ ${analysisResults.parameters.prrThreshold}
- χ² ≥ ${analysisResults.parameters.chiSquareThreshold}
- Cases ≥ ${analysisResults.parameters.minCases}

3. BAYESIAN CONFIDENCE PROPAGATION NEURAL NETWORK (BCPNN)
Information Component (IC):
- IC = log₂(Observed/Expected) = log₂(a/E₁₁)
- E₁₁ = (a+b)(a+c)/N

IC₀₂₅ (Lower bound of 95% credibility interval):
- Variance = (1/a - 1/N) + (1/(a+b) - 1/N) + (1/(a+c) - 1/N)
- IC₀₂₅ = IC - 1.96 × √(Variance/ln²(2))

Significance Criteria: IC₀₂₅ > ${analysisResults.parameters.icThreshold}

==================================================
DETAILED CALCULATIONS BY MEDICATION
==================================================

`;

            // Add detailed calculations for each medication
            Object.entries(detailedCalculations).forEach(([medName, calculations]) => {
                docxContent += `\n\n*** ${medName.toUpperCase()} ***\n`;
                docxContent += `Total Cases: ${analysisResults.medicationDataSets[medName].deduplicated.length}\n`;
                docxContent += `Significant Signals: ${analysisResults.medicationSignals[medName].filter(s => s.rorSignificant || s.prrSignificant || s.icSignificant).length}\n\n`;
                
                Object.entries(calculations).forEach(([pairKey, calc]) => {
                    const { a, b, c, d } = calc.contingencyTable;
                    const drugReaction = pairKey.replace('_', ' - ');
                    
                    docxContent += `\nDRUG-REACTION PAIR: ${drugReaction}\n`;
                    docxContent += `Contingency Table:\n`;
                    docxContent += `  a (drug+reaction): ${a}\n`;
                    docxContent += `  b (drug-reaction): ${b}\n`;
                    docxContent += `  c (reaction-drug): ${c}\n`;
                    docxContent += `  d (neither): ${d}\n`;
                    docxContent += `  Total: ${a + b + c + d}\n\n`;

                    // ROR Calculations
                    if (calc.calculations.ror) {
                        const ror = calc.calculations.ror;
                        docxContent += `ROR CALCULATION:\n`;
                        docxContent += `  ${ror.formula}\n`;
                        docxContent += `  ${ror.calculation}\n`;
                        docxContent += `  ln(ROR) = ${ror.lnROR.toFixed(4)}\n`;
                        docxContent += `  Standard Error = ${ror.standardError.toFixed(4)}\n`;
                        docxContent += `  95% CI: [${ror.lowerCI.toFixed(4)}, ${ror.upperCI.toFixed(4)}]\n`;
                        docxContent += `  Significant: ${ror.significant ? 'YES' : 'NO'} (${ror.criteria})\n\n`;
                    }

                    // PRR Calculations
                    if (calc.calculations.prr) {
                        const prr = calc.calculations.prr;
                        docxContent += `PRR CALCULATION:\n`;
                        docxContent += `  ${prr.formula}\n`;
                        docxContent += `  ${prr.calculation}\n`;
                        docxContent += `  ${prr.chiSquareFormula}\n`;
                        docxContent += `  Expected value: ${prr.expectedValue.toFixed(4)}\n`;
                        docxContent += `  χ² = ${prr.chiSquareValue.toFixed(4)}\n`;
                        docxContent += `  Significant: ${prr.significant ? 'YES' : 'NO'} (${prr.evansCriteria})\n\n`;
                    }

                    // BCPNN Calculations
                    if (calc.calculations.bcpnn) {
                        const bcpnn = calc.calculations.bcpnn;
                        docxContent += `BCPNN/IC CALCULATION:\n`;
                        docxContent += `  ${bcpnn.formula}\n`;
                        docxContent += `  ${bcpnn.expectedFormula}\n`;
                        docxContent += `  Expected value (E₁₁): ${bcpnn.expectedValue.toFixed(4)}\n`;
                        docxContent += `  ${bcpnn.calculation}\n`;
                        docxContent += `  Variance: ${bcpnn.variance.toFixed(6)}\n`;
                        docxContent += `  IC₀₂₅: ${bcpnn.ic025.toFixed(4)}\n`;
                        docxContent += `  Significant: ${bcpnn.significant ? 'YES' : 'NO'} (${bcpnn.criteria})\n\n`;
                    }

                    docxContent += `${'='.repeat(50)}\n`;
                });
            });

            // Add summary statistics
            docxContent += `\n\n==================================================\n`;
            docxContent += `SUMMARY STATISTICS\n`;
            docxContent += `==================================================\n\n`;
            docxContent += `Total Medications Analyzed: ${Object.keys(analysisResults.medicationDataSets).length}\n`;
            docxContent += `Total Cases: ${analysisResults.totalStudyCases.toLocaleString()}\n`;
            docxContent += `Total Significant Signals: ${analysisResults.signals.filter(s => s.rorSignificant || s.prrSignificant || s.icSignificant).length}\n`;
            docxContent += `Countries Represented: ${Object.keys(analysisResults.demographics.country).length}\n`;
            docxContent += `Study Period: ${analysisResults.parameters.studyPeriod}\n`;
            docxContent += `Database Version: ${analysisResults.parameters.databaseVersion}\n`;

            if (analysisResults.parameters.deduplicationEnabled) {
                docxContent += `\nDEDUPLICATION SUMMARY:\n`;
                Object.entries(deduplicationResults.medications).forEach(([medName, stats]) => {
                    const reductionRate = ((stats.duplicatesRemoved / stats.originalCount) * 100).toFixed(1);
                    docxContent += `${medName}: ${stats.originalCount} → ${stats.deduplicatedCount} (${reductionRate}% reduction)\n`;
                });
            }

            // Create and download the text file (since we can't create actual DOCX in browser)
            const blob = new Blob([docxContent], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `FAERS_Detailed_Statistics_Equations_${new Date().toISOString().split('T')[0]}.txt`;
            a.click();
            URL.revokeObjectURL(url);

            // Also create an Excel file with calculations
            const wb = XLSX.utils.book_new();
            
            Object.entries(detailedCalculations).forEach(([medName, calculations]) => {
                const calcData = [
                    ['Drug-Reaction Pair', 'Cases (a)', 'Drug w/o Reaction (b)', 'Reaction w/o Drug (c)', 'Neither (d)', 
                     'ROR', 'ROR Lower CI', 'ROR Upper CI', 'ROR Formula', 'ROR Calculation',
                     'PRR', 'Chi Square', 'PRR Formula', 'PRR Calculation',
                     'IC', 'IC025', 'Expected (E11)', 'IC Formula', 'IC Calculation']
                ];
                
                Object.entries(calculations).forEach(([pairKey, calc]) => {
                    const { a, b, c, d } = calc.contingencyTable;
                    const rorCalc = calc.calculations.ror || {};
                    const prrCalc = calc.calculations.prr || {};
                    const bcpnnCalc = calc.calculations.bcpnn || {};
                    
                    calcData.push([
                        pairKey.replace('_', ' - '),
                        a, b, c, d,
                        rorCalc.calculation ? rorCalc.calculation.split(' = ')[2] : 'N/A',
                        rorCalc.lowerCI || 'N/A',
                        rorCalc.upperCI || 'N/A',
                        rorCalc.formula || 'N/A',
                        rorCalc.calculation || 'N/A',
                        prrCalc.calculation ? prrCalc.calculation.split(' = ')[2] : 'N/A',
                        prrCalc.chiSquareValue || 'N/A',
                        prrCalc.formula || 'N/A',
                        prrCalc.calculation || 'N/A',
                        bcpnnCalc.calculation ? bcpnnCalc.calculation.split(' = ')[2] : 'N/A',
                        bcpnnCalc.ic025 || 'N/A',
                        bcpnnCalc.expectedValue || 'N/A',
                        bcpnnCalc.formula || 'N/A',
                        bcpnnCalc.calculation || 'N/A'
                    ]);
                });
                
                const calcWs = XLSX.utils.aoa_to_sheet(calcData);
                XLSX.utils.book_append_sheet(wb, calcWs, `${medName.substring(0, 31)}_Calc`);
            });
            
            XLSX.writeFile(wb, `FAERS_Detailed_Calculations_${new Date().toISOString().split('T')[0]}.xlsx`);
        }

        function downloadAllResults() {
            downloadRawData();
            setTimeout(() => downloadStudyTables(), 1000);
            setTimeout(() => downloadManuscript(), 2000);
            setTimeout(() => downloadStatisticsDocx(), 3000);
        }
    </script>
</body>
</html>
